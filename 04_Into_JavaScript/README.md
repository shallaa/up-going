# You Don't Know JS: Up & Going
# Chapter 2: Into JavaScript

이전 1장에서는 변수, 루프, 조건문과 함수 같은 프로그래밍의 기본 구성을 소개했다. 물론 모든 코드는 자바스크립트로 작성되었다. 그러나 이번 장에서는, 특히 자바스크립트 개발자로서 성장하기 위해 반드시 알아야할 것들에 초점을 맞추려고 한다.

이번 2장에서는 추후 *YDKJS* 시리즈 책들에서 완전히 분석할 많은 개념들을 소개할 것이다. 이번 2장을 나머지 다른 시리즈들 전체에서 자세히 다루게 될 주제들의 개요로 생각해도 좋겠다.

만약 자바스크립트를 처음 접한다면, 여기에 나온 개념들과 예제 코드를 여러 번 살펴보며 많은 시간을 할애해야만 한다. 어차피 좋은 기초란 벽돌을 쌓는 것과 같아서, 처음부터 끝까지 모든 것을 바로 이해할 것이라고 기대하지 말자.

자바스크립트를 깊이있게 배우는 여행은 여기서부터 시작이다.

**참고:** 1장에서도 말했듯이, 이번 2장을 공부하면서 반드시 모든 코드를 스스로 작성해보아야 한다. 몇몇 코드는 이 글을 작성할 당시에 자바스크립트 최신 버전(일반적으로 'ES6"라 불리는 자바스크립트 공식 명칭 ECMAScript의 6번째 버전) 사용능력을 가정하고 있음을 주의하라. 만약 ES6 이전 브라우저를 사용한다면 코드가 동작하지 않을 수 있다. 최신 브라우저(크롬, 파이어폭스, 인터넷익스플로러 같은)의 최신 업데이트를 사용해야한다. 

#Values & Types

1장에서 말한바와 같이, 자바스크립트는 변수 타입이 아닌 값 타입을 갖는다. 아래와 같은 내장 타입들이 있다:

* `string`
* `number`
* `boolean`
* `null` and `undefined`
* `object`
* `symbol` ( ES6에 추가 됨 )

자바스크립트에는 값이 어떤 타입인지 검사할 수 있는 `typeof` 연산자가 있다.

```js
var a;
typeof a;  // "undefined"

a = "hello world";
typeof a;  // "string"

a = 42;
typeof a;  // "number"

a = true;
typeof a;  // "boolean"

a = null;
typeof a;  // "object" -- weird, bug

a = undefined;
typeof a;  // "undefined"

a = { b: "c" };
typeof a;  // "object"
```

`typeof` 연산자로부터 반환되는 값은 항상 6개 문자값(ES6에서는 7개 - 심볼 <sub>symbol</sub> 타입 포함) 중 하나이다. 즉, `typeof "abc"` 는 `string`이 아닌 `"string"` 을 반환한다.

이 예제에서 `a` 라는 변수가 어떻게 다른 모든 타입의 값을 가질 수 있는지, 그리고 그 겉보기와 다르게 `typeof a`는 "`a`의 타입"이 아닌 "현재 `a`에 들어있는 값의 타입" 에 대해 묻는지 알아보자.

`typeof null`은 `"null"`을 반환하는 것을 예상하지만 `"object"`로 잘못 반환하는 흥미로운 케이스다.

**주의** : 이것은 자바스크립트의 오래된 버그이지만, 결코 고칠 수 없는 버그이다. 웹상의 너무 많은 코드가 그 버그에 의존하고 있기 때문에 그것을 고치면 더 많은 버그가 발생한다.

또한, `a = undefined`를 유의하자. 명시적으로 `a`를 `undefined`값으로 설정했지만, 예제 맨 윗 줄의 `var a;` 같이 아직 값이 설정되지 않은 변수와 동작상으로는 차이가 없다. 변수는 값을 반환하지 않는 함수나 `void` 연산자 사용을 포함한 여러가지 방식으로 "undefined" 값 상태를 가질 수 있다.  

#Objects

`object`(객체) 타입은 각각의 타입을 가진 값을 가진 프로퍼티를 설정할 수 있는 하나의 복합 값을 참조한다. 아마도 자바스크립트에서 가장 유용한 값 타입 중 하나일 것이다.

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

다음은 `obj` 값을 시각적으로 생각하는데 유용하다.

<img src="fig5.png">

프로퍼티(속성)들은 점 표기법 (i.e., `obj.a`) 또는 괄호 표기법 (i.e., `obj[a]`)으로 접근될 수 있다. 점 표기법은 짧고 일반적으로 읽기 쉬워서 가능하면 선호된다. 

괄호 표기법은 만약 당신이 `obj["hello world"]` 처럼 특수문자를 가진 속성명을 유용하다. 그런 속성들은 종종 괄호 표기법에 접근할 떄 키*key*가 된다. `[ ]`표기법은 변수(다음에 설명) 또는 문자열 리터럴("..", '..'로 묶여야 할)을 필요로 한다.

물론, 괄호 표기법은 다음과 같이 또다른 변수에 그 이름이 저장되어 있는 속성/키에 접근할 때 유용하다.

```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```


**참고 :** 자바스크립트 `object`들에 대한 더 많은 정보가 필요하다면, 시리즈 중 *this & Prototypes* 의 제 3장을 살펴보자.
 
자바스크립트 프로그램에서 일반적으로 사용하게 될 배열과 함수라는 두 가지 다른 값 타입이 있다. 그러나 진정한 내장 타입이라기 보다 하위 타입(`object` 타입의 특화된 버전들)이라고 생각해야 한다.

#Arrays

배열은 특정한 프로퍼티/키가 아닌 숫자로 색인된 위치 값(특정 타입의)을 가진 객체 `object`이다.

예제:

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```

**참고 :** 자바스크립트처럼 0 부터 숫자를 세는 언어들은 `0`을 배열에서 인덱스의 첫 번째 인자로 사용한다.

다음은 `arr`을 시각화하는데 도움이 될 것이다.
<img src="fig5.png">

배열은 특수한 객체(`typeof`로 의미하는)이기 때문에, 자동으로 업데이트되는 `length` 속성을 포함한 속성들을 가진다.

이론적으로는 지정된 속성을 가진 일반 객체로 배열을 사용할 수 있고, 배열과 비슷하게 오직 숫자 속성(0, 1, 기타등등)만을 가진 `object`를 사용할 수 있다. 그러나 일반적으로는 각 타입의 부적절한 사용으로 여겨진다.

가장 훌륭하고 자연스러운 접근 방식은 숫자로 배치된 값에 배열을 사용하고 지정된 속성에 객체를 사용하는 것이다.  

#Functions

자바스크립트 프로그램에서 보게될 또 다른 객체의 하위타입은 함수이다.

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

함수는 객체의 하위 타입이다. 함수는 `typeof`로 함수의 주 타입인 `"function"`을 반환한다. 제한된 경우에서만 `foo.bar`와 같은 함수 객체 속성을 사용할 것이다. 

**참고 :** 자바스크립트 값과 타입에 대한 더 많은 정보는 YDKJ의 시리즈 중 *Types & Grammar*의 첫 두 장을 살펴보자. 

#Built-In Type Methods

앞에서 언급한 내장 타입과 하위 타입은 매우 강력하고 유용한 속성과 메소드로 동작한다. 
 
예제.

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

`a.toUpperCase()`를 호출하는 "방법"은 값에 존재하는 메소드보다 더 복잡하다.

간단히 말해, 프로토타입에 `toUpperCase()` 메소드를 정의하는 객체 래퍼인 원시 `string`타입과 쌍을 이루는 "네이티브"라 불리는 `String`(대문자 S) 객체 래퍼 형태가 있다. 

속성 또는 메소드(예, 이전 예제에서의 `a.toUpperCase()`)를 참조하여 `"hello world"` 같은 원시 값을 `object`로 사용할 때, 자바스크립트는 자동적으로 값을 객체 래퍼(숨겨진)에 **담는다.(박싱한다)** 

`string` 값은 `String` 객체로, `number`는 `Number` 객체로, `boolean`은 `Boolean` 객체로 래핑될 수 있다. 대부분의 경우, 이러한 값의 객체 래퍼 형식에 대해 걱정하거나 직접 사용할 필요가 없다. 실제로 모든 경우에 원시 값 형식이 더 선호되며 자바스크립트가 나머지 부분을 처리할 것이다.

**참고 : ** 자바스크립트 네이티브와 박싱에 대한 더 많은 정보는 YDKJ의 시리즈 중 *Types & Grammar*의 3장을 살펴보자. 객체의 프로토타입을 더 잘 이해하기 위해서는 *this & Object Prototypes*의 제 5장을 살펴보자.
