# You Don't Know JS: Up & Going
# Chapter 2: Into JavaScript

이전 1장에서는 변수, 루프, 조건문과 함수 같은 프로그래밍의 기본 구성을 소개했다. 물론 모든 코드는 자바스크립트로 작성되었다. 그러나 이번 장에서는, 특히 자바스크립트 개발자로서 성장하기 위해 반드시 알아야할 것들에 초점을 맞추려고 한다.

이번 2장에서는 추후 *YDKJS* 시리즈 책들에서 완전히 분석할 많은 개념들을 소개할 것이다. 이번 2장을 나머지 다른 시리즈들 전체에서 자세히 다루게 될 주제들의 개요로 생각해도 좋겠다.

만약 자바스크립트를 처음 접한다면, 여기에 나온 개념들과 예제 코드를 여러 번 살펴보며 많은 시간을 할애해야만 한다. 어차피 좋은 기초란 벽돌을 쌓는 것과 같아서, 처음부터 끝까지 모든 것을 바로 이해할 것이라고 기대하지 말자.

자바스크립트를 깊이있게 배우는 여행은 여기서부터 시작이다.

**참고:** 1장에서도 말했듯이, 이번 2장을 공부하면서 반드시 모든 코드를 스스로 작성해보아야 한다. 몇몇 코드는 이 글을 작성할 당시에 자바스크립트 최신 버전(일반적으로 'ES6"라 불리는 자바스크립트 공식 명칭 ECMAScript의 6번째 버전) 사용능력을 가정하고 있음을 주의하라. 만약 ES6 이전 브라우저를 사용한다면 코드가 동작하지 않을 수 있다. 최신 브라우저(크롬, 파이어폭스, 인터넷익스플로러 같은)의 최신 업데이트를 사용해야한다. 

#Values & Types

1장에서 말한바와 같이, 자바스크립트는 변수 타입이 아닌 값 타입을 갖는다. 아래와 같은 내장 타입들이 있다:

* `string`
* `number`
* `boolean`
* `null` and `undefined`
* `object`
* `symbol` ( ES6에 추가 됨 )

자바스크립트에는 값이 어떤 타입인지 검사할 수 있는 `typeof` 연산자가 있다.

```js
var a;
typeof a;  // "undefined"

a = "hello world";
typeof a;  // "string"

a = 42;
typeof a;  // "number"

a = true;
typeof a;  // "boolean"

a = null;
typeof a;  // "object" -- weird, bug

a = undefined;
typeof a;  // "undefined"

a = { b: "c" };
typeof a;  // "object"
```

`typeof` 연산자로부터 반환되는 값은 항상 6개 문자값(ES6에서는 7개 - 심볼 <sub>symbol</sub> 타입 포함) 중 하나이다. 즉, `typeof "abc"` 는 `string`이 아닌 `"string"` 을 반환한다.

이 예제에서 `a` 라는 변수가 어떻게 다른 모든 타입의 값을 가질 수 있는지, 그리고 그 겉보기와 다르게 `typeof a`는 "`a`의 타입"이 아닌 "현재 `a`에 들어있는 값의 타입" 에 대해 묻는지 알아보자.

`typeof null`은 `"null"`을 반환하는 것을 예상하지만 `"object"`로 잘못 반환하는 흥미로운 케이스다.

**주의** : 이것은 자바스크립트의 오래된 버그이지만, 결코 고칠 수 없는 버그이다. 웹상의 너무 많은 코드가 그 버그에 의존하고 있기 때문에 그것을 고치면 더 많은 버그가 발생한다.

또한, `a = undefined`를 유의하자. 명시적으로 `a`를 `undefined`값으로 설정했지만, 예제 맨 윗 줄의 `var a;` 같이 아직 값이 설정되지 않은 변수와 동작상으로는 차이가 없다. 변수는 값을 반환하지 않는 함수나 `void` 연산자 사용을 포함한 여러가지 방식으로 "undefined" 값 상태를 가질 수 있다.  

#Objects

`object`(객체) 타입은 각각의 타입을 가진 값을 가진 프로퍼티를 설정할 수 있는 하나의 복합 값을 참조한다. 아마도 자바스크립트에서 가장 유용한 값 타입 중 하나일 것이다.

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

다음은 `obj` 값을 시각적으로 생각하는데 유용하다.

<img src="fig5.png">

프로퍼티(속성)들은 점 표기법 (i.e., `obj.a`) 또는 괄호 표기법 (i.e., `obj[a]`)으로 접근될 수 있다. 점 표기법은 짧고 일반적으로 읽기 쉬워서 가능하면 선호된다. 

괄호 표기법은 만약 당신이 `obj["hello world"]` 처럼 특수문자를 가진 속성명을 유용하다. 그런 속성들은 종종 괄호 표기법에 접근할 떄 키*key*가 된다. `[ ]`표기법은 변수(다음에 설명) 또는 문자열 리터럴("..", '..'로 묶여야 할)을 필요로 한다.

물론, 괄호 표기법은 다음과 같이 또다른 변수에 그 이름이 저장되어 있는 속성/키에 접근할 때 유용하다.

```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```


**참고 :** 자바스크립트 `object`들에 대한 더 많은 정보가 필요하다면, 시리즈 중 *this & Prototypes* 의 제 3장을 살펴보자.
 
자바스크립트 프로그램에서 일반적으로 사용하게 될 배열과 함수라는 두 가지 다른 값 타입이 있다. 그러나 진정한 내장 타입이라기 보다 하위 타입(`object` 타입의 특화된 버전들)이라고 생각해야 한다.

#Arrays

배열은 특정한 프로퍼티/키가 아닌 숫자로 색인된 위치 값(특정 타입의)을 가진 객체 `object`이다.

예제:

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```

**참고 :** 자바스크립트처럼 0 부터 숫자를 세는 언어들은 `0`을 배열에서 인덱스의 첫 번째 인자로 사용한다.

다음은 `arr`을 시각화하는데 도움이 될 것이다.
<img src="fig5.png">

배열은 특수한 객체(`typeof`로 의미하는)이기 때문에, 자동으로 업데이트되는 `length` 속성을 포함한 속성들을 가진다.

이론적으로는 지정된 속성을 가진 일반 객체로 배열을 사용할 수 있고, 배열과 비슷하게 오직 숫자 속성(0, 1, 기타등등)만을 가진 `object`를 사용할 수 있다. 그러나 일반적으로는 각 타입의 부적절한 사용으로 여겨진다.

가장 훌륭하고 자연스러운 접근 방식은 숫자로 배치된 값에 배열을 사용하고 지정된 속성에 객체를 사용하는 것이다.  

#Functions

자바스크립트 프로그램에서 보게될 또 다른 객체의 하위타입은 함수이다.

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

함수는 객체의 하위 타입이다. 함수는 `typeof`로 함수의 주 타입인 `"function"`을 반환한다. 제한된 경우에서만 `foo.bar`와 같은 함수 객체 속성을 사용할 것이다. 

**참고 :** 자바스크립트 값과 타입에 대한 더 많은 정보는 YDKJS의 시리즈 중 *Types & Grammar*의 첫 두 장을 살펴보자. 

#Built-In Type Methods

앞에서 언급한 내장 타입과 하위 타입은 매우 강력하고 유용한 속성과 메소드로 동작한다. 
 
예제.

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

`a.toUpperCase()`를 호출하는 "방법"은 값에 존재하는 메소드보다 더 복잡하다.

간단히 말해, 프로토타입에 `toUpperCase()` 메소드를 정의하는 객체 래퍼인 원시 `string`타입과 쌍을 이루는 "네이티브"라 불리는 `String`(대문자 S) 객체 래퍼 형태가 있다. 

속성 또는 메소드(예, 이전 예제에서의 `a.toUpperCase()`)를 참조하여 `"hello world"` 같은 원시 값을 `object`로 사용할 때, 자바스크립트는 자동적으로 값을 객체 래퍼(숨겨진)에 **담는다.(박싱한다)** 

`string` 값은 `String` 객체로, `number`는 `Number` 객체로, `boolean`은 `Boolean` 객체로 래핑될 수 있다. 대부분의 경우, 이러한 값의 객체 래퍼 형식에 대해 걱정하거나 직접 사용할 필요가 없다. 실제로 모든 경우에 원시 값 형식이 더 선호되며 자바스크립트가 나머지 부분을 처리할 것이다.

**참고 : ** 자바스크립트 네이티브와 박싱에 대한 더 많은 정보는 YDKJS의 시리즈 중 *Types & Grammar*의 3장을 살펴보자. 객체의 프로토타입을 더 잘 이해하기 위해서는 *this & Object Prototypes*의 제 5장을 살펴보자.

#Comparing Values

자바스크립트 프로그램에서 값 비교의 두 가지 메인 타입은 *동등 연산자*와 *부등 연산자*이다. 어떤 값 타입을 비교하는지와 상관없이, 비교의 결과는 엄격하게 `boolean` 값(참 또는 거짓)이다.

#Coercion

1장에서 간단히 언급했던 강제형변환에 대해 다시 살펴보자.

강제형변환은 자바스크립트에서 *명시적 형변환*과 *암묵적 형변환*의 두 가지 형태이다. 명시적 강제형변환은 한 타입에서 또 다른 타입으로 변환되는 것을 코드에서 명확하게 볼 수 있는 것을 말한다. 그에 반해 암묵적 강제형변환은 다른 연산자의 불명확한 부작용으로 타입 변환이 발생한다.

강제형변환이 놀랄만한 결과를 가져올 수 있다는 사실로 인해 "강제형변환은 악마다" 라는 말을 들어 본 적이 있을 것이다. 아마도 개발자에게 개발언어가 그들을 놀라게 하는 것 보다 더 좌절하게 하는 것은 아무것도 없을 것이다.

강제형변환은 악마가 아닐 뿐아니라, 놀라게 하는 것도 아니다. 사실, 강제형변환으로 작성할 수 있는 대부분의 경우는 매우 합리적이고 이해하기 쉬우며 코드의 가독성을 향상시키는데 사용될 수 있다. 그러나 더이상은 논쟁하지 않을 것이다. -- YDKJS 시리즈의 제 4장 *Types & Grammar* 에서 모든 부분을 다룰 것이다.

다음은 명시적 형변환의 예시이다:

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

다음은 암묵적 형변환의 예시이다:

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#Truthy & Falsy

제 1장에서 non-`boolean` 값이 `boolean` 값으로 강제 형변환될 때, 참인지 또는 거짓인지와 같은 값의 "참"과 "거짓"에 대해 간략하게 다루었다. 

자바스크립트에서 거짓인 경우는 다음과 같다.
 
* `""` (empty string)
* `0`, `-0`, `NaN` (invalid `number`)
* `null`, `undefined`
* `false`

위의 거짓에 해당하지 않는 것은 모두 참이다. 다음은 몇 가지 예시이다.

* `"hello"`
* `42`
* `true`
* `[ ]`, `[ 1, "2", 3 ]` (arrays)
* `{ }`, `{ a: 42 }` (objects)
* `function foo() { .. }` (functions)

실제로 `boolean` 값으로 강제형변환 된다면 non-`boolean` 값은 참/거짓 강제형변환을 뒤따라 나온다는 것을 기억하자. 값이 `boolean`이 아닐 때, 값을 `boolean`으로 강제형변환하는 상황을 혼동하기 쉽다.

#Equality

`==, ===, !=, and !==` 4가지 동등연산자가 있다. `!` 형식은 그 반대편과 대칭인 "일치하지 않는" 버전이다. 불일치연산자와 부등연산자를 혼동하지 말아야 한다.

`==`와 `===`의 차이점은 일반적으로 `==`는 값이 일치하는지를 체크하고 `===`는 값과 타입 두 가지 모두 일치하는지를 체크한다는 것이다. 그러나 이것은 부정확하다. 그들을 구분짓는 적합한 방법은 `==`가 강제형변환이 허용되는 값 일치를 체크하고 `===`가 강제형변환을 허용하지 않고 갑 일치를 체크한다는 것이다. 이런 이유로 `===`는 "일치연산자(엄격한 일치?)"로 불린다.

`==`의 느슨한 일치 비교로는 허용되고, `===`의 엄격한 일치로는 허용되지않는 암묵적 형변환을 생각해보자.

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

`a == b` 비교에서, 자바스크립트(JS)는 타입이 일치하지 않는 것을 알고 있기 때문에, 단순히 값 일치가 체크되어지는 타입이 일치할 때까지 타입이 다른 하나 또는 두 개의 값을 강제형변환하기위한 일련의 단계를 거치게 된다.

강제형변환으로 `a == b` 를 참으로 만들 가능성이 있는 두 가지 방법이 있다. 비교는 결국 `42 == 42` 또는  `"42" == "42"` 둘 중 하나이다. 어떤 것일까?

그 대답은 `42 == 42` 를 비교하기 위해 `"42"`는 `42`가 된다. 이런 간단한 예시에서, 마지막 결과가 같다면 처리방식은 중요하지 않다. 어떻게 도달할 것이냐가 뿐만아니라 비교의 마지막 결과 무엇인지 보다 더 복잡한 경우들이 있다. 

`a === b` 는 거짓이다. 왜냐하면 강제형변환이 허용되지 않았다. 그래서 단순 값 비교는 분명히 실패한다. 많은 개발자들은 `===`가 좀 더 예측가능하다고 느껴서 항상 `==`가 아닌  `===`을 사용한다. 이런 관점은 매우 근시안적이다. `==`는 만약 어떻게 작동하는 지 배울 시간이 된다면 당신의 프로그램을 돕는 강력한 툴이 될 것이다.

비교에서 강제형변환이 어떻게 작동 하는지에 대한 핵심 세부사항을 모두 다루지는 않을 것이다. 상당부분 매우 합리적이지만 조심해야할 몇 가지 중요한 예외 경우들이 있다. 정확한 규칙을 알기 위해 ES5의 11.9.3‘(http://www.ecma-international.org/ecma-262/5.1/)’을 읽으며, 모든 부정적인 과대광고에 비해 그 매커니즘이 너무나 단순한 것에 놀라게 될 것이다.

여러 가지 세부 사항들을 몇 가지 간단한 요점으로 요약하고, 다양한 상황에서 == 또는 ===를 사용할지 여부를 알 수 있도록 도와줄 다음과 같은 간단한 규칙이 있다.

* 비교에서 값(side(?)로 알려진)이 참 또는 거짓이라면 `==` 대신 `===`을 사용하자.

* 비교에서 값이 특정 값(0, "", [], 빈 배열)이라면, `==` 대신 `===`을 사용하자.

* 다른 모든 경우에서, `==`을 사용하는 것이 안전하다. 안전할 뿐만아니라 많은 경우에 가독성을 향상시키도록 코드를 단순화한다.

이 규칙의 핵심은 자신의 코드에 대해 비판적으로 생각할 것과 일치 비교연산으로 얻어진 변수로부터 어떤 값이 나올 수 있는지에 대한 것이다. 만약 값에 대한 확신이 있다면 `==`이 안전하니 사용하자. 만약 값에 대한 확신이 없다면 `===`을 사용하자. 간단하다.

`!=` 부등연산자는 `==` 동등연산자와 쌍을 이루고 `!==` 불일치연산자는 `===` 일치연산자와 쌍을 이룬다. 지금까지 살펴본 모든 규칙들은 부등연산자 비교에서 대칭을 이룬다.

만약 `object`(함수와 배열을 포함한)처럼 기본 타입이 아닌 2개를 비교한다면, `==`와 `===` 비교 규칙을 특히 외워두자. 왜냐하면 그 값들은 사실 레퍼런스에 영향을 받기 때문에, `==`와 `===` 비교연산은 단순히 레퍼런스가 일치하는지 여부를 확인하고 기본 값에 대해서는 확인하지 않는다.

예를 들어, 배열은 기본적으로 콤마(,)로 모든 값 사이를 연결한 `string`으로 강제형변환한다. 동일한 내용을 가진 두 개의 배열이 `==`하다고 생각할지 모른다. 그러나 그들은 그렇지 않다.

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

참고 : `==` 동등연산자 규칙에 대해 더 많은 정보를 알고 싶다면, ES5 (11.9.3)와 이 시리즈 *Type & Grammar*의 4장을 살펴보자. 값과 레퍼런스는 2장을 살펴보자. 

#Inequality

`<`, `>`, `<=`, `>=` 연산자는 "관계형 비교연산자"라 불리는 부등연산자로 쓰인다. 전형적으로 `number` 처럼 순서를 나타내어 비교할 만한 값에 사용된다. `3 < 4` 를 보면 이해하기 쉽다.

그러나 자바스크립트의 `string` 값은 전형적인 알파벳 규칙(`"bar" < "foo"`)을 이용하는 부등연산자로로 비교할 수 있다. 

강제형변환은 어떤가? `==` 비교연산자와 유사한 규칙(정확히 일치하지는 않지만)을 부등연산자에 적용한다. 특히, `===` "엄격한 동등"연산자와 같은 방식으로 강제형변환을 허용하지 않는 "엄격한 부등" 연산자는 없다.

다음을 생각해보자.

```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

여기에선 어떻게 될까? ES5의 11.8.5에서 만약 `<` 비교에서 두 값 모두 `b < c`처럼 `string`이라면, 사전 편집순(사전처럼 알파벳순으로)으로 비교된다. 그러나 하나 또는 두 값 모두 `a < b`처럼 `string`이 아니라면, 두 값은 `number`로 강제형변환되고, 일반적인 숫자 비교가 된다.

잠재적으로 다른 값 타입 사이 비교에서 직면하게되는 가장 큰 문제는 값 중 하나가 유효한 숫자로 만들어지지 않을 때, 다음과 같이 사용할 "엄격한 부등"형태가 없다는 것이다.   

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

잠깐, 어떻게 세 가지 비교 모두 `false`일 수 있을까? 왜냐하면 값`b`는 `<`와 `>`의 비교에서 "유효하지 않은 숫자 값" `NaN`으로 강제형변환되고, `NaN`은 다른 값보다 더 크거나 더 작지않다.

`==` 비교는 다른 이유로 실패한다. `a == b`가 만약 앞의 경우에서 설명한 것처럼 `42 = NaN` 또는 `"42" == "foo"`로 해석된다면 실패할 수 있다.

참고 : 부등연산자 규칙에 대해 더 많은 정보를 알고 싶다면, ES5의 11.8.5와 이 시리즈의 *Types & Grammar*의 제 4장을 살펴보자.

#Variables

자바스크립트에서 변수명(함수명을 포함하여)은 유효한 *식별자*여야한다. 유니코드와 같이 비전통적인 문자일 때, 식별자에서 유효한 문자에 대한 엄격하고 완전한 규칙은 다소 복잡하다. 만약 오직 전형적인 ASCII 영숫자만을 고려한다면 그 규칙은 간단하다.

식별자는 `a - z, A - Z, $, _`로 시작해야하고, 그 문자들과 숫자 `0 - 9`를 더한 것을 가질 수 있다. 

일반적으로 변수 식별자와 동일한 규칙을 속성명에 적용한다. 그러나 특정 단어는 변수로 사용될 수 없지만 속성명으로는 사용할 수 있다. 이런 단어들은 "예약어"라고 하고 자바스크립트 키워드(`for`, `in`, `if`, 등) 뿐만아니라 `null`, `true`, `false`를 포함한다.

참고: 예약어에 대한 더 많은 정보는 이 시리즈의 *Types & Grammar*의 부록 A를 살펴보자.

#Function Scopes

현재 함수 스코프에 속한 변수 또는 또는 함수 외부 최상위에 전역 스코프를 선언하는데 `var` 키워드를 사용한다.

#Hoisting

스코프 내부에 `var`이 나올때마다, 그 선언은 전체 스코프에 속하고 어디든 접근할 수 있다. 

`var` 선언이 스코프의 상단으로 개념상으로 이동할때, 은유적으로 이 행위를 호이스팅(hoisting)이라고 한다. 기술적으로 이 과정은 어떻게 코드가 컴파일되는지에 따라 더 정확하게 설명된다. 그러나 지금은 그 세부사항을 건너뛰겠다.

생각해보자:

```js
var a = 2;

foo();					// works because `foo()`
						// declaration is "hoisted"

function foo() {
	a = 3;

	console.log( a );	// 3

	var a;				// declaration is "hoisted"
						// to the top of `foo()`
}

console.log( a );	// 2
```

경고: `var` 선언보다 먼저 변수를 사용하기 위해 변수 호이스팅에 의존하는 것이 일반적이거나 좋은 생각이 아니다. 매우 혼란을 줄 수 있다. 공식 선언 전에 `foo()`를 호출하는 것과 마찬가지로 호이스트된 함수 선언을 사용하는 것이 훨씬 더 일반적이다.

#Nested Scopes

변수를 선언할 때, 하위/내부 뿐아니라 스코프 내부 어디든 가능하다.

```js
function foo() {
	var a = 1;

	function bar() {
		var b = 2;

		function baz() {
			var c = 3;

			console.log( a, b, c );	// 1 2 3
		}

		baz();
		console.log( a, b );		// 1 2
	}

	bar();
	console.log( a );				// 1
}

foo();
```

`baz()`내부에서만 선언했기 때문에 `c`가 `bar()`의 내부에서는 사용할 수 없다는 것에 주의하자. `b`도 동일한 이유로 `foo()`에서 사용할 수 없다. 

사용할 수 없는 스코프 내의 변수의 값에 접근하려고 한다면, 잘못된 참조 오류(ReferenceError)가 발생한다. 선언되지않은 변수를 설정하려고 한다면, 결국 최상위 전역 스코프에 변수를 생성하거나(좋지않다!) "엄격 모드"에 의한 에러를 발생시키게 된다.("엄격 모드" 참조) 
다음을 살펴보자.

```js
function foo() {
	a = 1;	// `a` not formally declared
}

foo();
a;			// 1 -- oops, auto global variable :(
```

이것은 매우 나쁜 예이다. 절대 하지 말자. 항상 공식적으로 변수를 선언하자.

함수 수준에서 변수 선언을 생성하는 것 뿐 아니라, ES6에서 `let` 키워드를 사용하여 개별 블록({..}의 쌍)에 속하는 변수를 선언한다. 게다가 약간의 미묘한 세부사항을 가진 스코프 규칙이 함수에서처럼 대략 비슷하게 동작한다.

```js
function foo() {
	var a = 1;

	if (a >= 1) {
		let b = 2;

		while (b < 5) {
			let c = b * 2;
			b++;

			console.log( a + c );
		}
	}
}

foo();
// 5 7 9
```

`var` 대신 `let`을 사용하기 때문에, `b`는 오직 `if`문에만 속하고 `foo()` 함수의 스코프 전체에는 속하지 않는다. 마찬가지로, `c`는 `while` 루프(loop)에만 속한다. 블록 스코프는 변수 스코프를 시간이 지나도 유지하기 훨씬 쉽게 만들 수 있는 세분화된 방식으로 관리하는데 매우 유용하다.

참고: 스코프에 대해 더 많은 정보는 이 시리즈의 *Scope & Closures*를 살펴보자. `let` 블록 스코프에 대한 더 많은 정보는 이 시리즈의 *ES6 & Beyond*를 살펴보자.
 
#Conditionals

제 1장에서 간략히 소개한 `if` 문 외에도, JavaScript는 반드시 알아야할 몇 가지 다른 조건 메커니즘을 제공한다.

때때로 다음과 같은 일련의 `if ..else..if`문을 작성한다.

```js
if (a == 2) {
	// do something
}
else if (a == 10) {
	// do another thing
}
else if (a == 42) {
	// do yet another thing
}
else {
	// fallback to here
}
```

이 구조는 작동하지만 모든 경우에 `a`를 지정해야하기 때문에 약간 번거롭다. 또 다른 옵션인 `switch`문이 있다.

```js
switch (a) {
	case 2:
		// do something
		break;
	case 10:
		// do another thing
		break;
	case 42:
		// do yet another thing
		break;
	default:
		// fallback to here
}
```

하나의 `case`에서만 switch 문(statement)을 작동시키려 한다면 `break`가 중요하다. 만약 `case`에서 `break`를 생략하면, 그 `case`는 일치하거나 실행하고, `case` 일치와 상관없이 다음 `case` 문을 실행한다. 이것이 때때로 유용한 "fall through"이다.

```js
switch (a) {
	case 2:
	case 10:
		// some cool stuff
		break;
	case 42:
		// other stuff
		break;
	default:
		// fallback
}
```

`a`는 `2` 또는 `10`이라면, "some cool stuff" 코드 문을 실행할 것이다. 

자바스크립트 조건식의 또 다른 형태는 "삼항 연산자"라 불리는 "조건 연산자"이다. 다음과 같이 하나의 `if..else`문 보다 더 간결한 형태이다. 

```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

테스트 표현식 `a > 41`가 `true`라면, 첫번째 절 `"hello"`가 결과로, 그렇지 않으면 두번째 절 `"world"`가 결과로 반환되고 그 결과가 무엇이든 `b`에 할당된다.

조건 연산자는 할당에 사용하지 않아도 되지만, 가장 일반적인 사용법이다. 

테스트 조건과 `switch`와 `?:`의 다른 패턴에 대해 더 많은 정보는 이 시리즈의 *Types & Grammar*를 살펴보자.

#Strict Mode

ES5는 특정 행위에 대한 규칙을 강화하는 "strict mode"를 언어에 추가했다. 일반적으로 이런 제한은 좀 더 안전하고 적절한 가이드라인 설정으로 코드를 유지하기 위함이다. 또한 엄격 모드의 준수는 일반적으로 코드가 엔진에 최적화되도록 한다. 엄격 모드는 코드에 큰 도움이 되며, 모든 프로그램에 사용해야 한다.

어디에 엄격 모드 pragma를 넣는지에 따라 개별 함수 또는 파일 전체에 엄격 모드를 적용할 수 있다. 

*pragma : 컴파일러 지시문. 컴파일러에 의도를 나타 내기 위해 프로그래머가 소스 코드에 포함시킨 데이터

```js
function foo() {
	"use strict";

	// this code is strict mode

	function bar() {
		// this code is strict mode
	}
}

// this code is not strict mode
```

다음과 비교해보자.

```js
"use strict";

function foo() {
	// this code is strict mode

	function bar() {
		// this code is strict mode
	}
}

// this code is strict mode
```

엄격 모드의 중요한 차이점 하나는 `var` 생략으로 암묵적인 자동 전역 변수 선언을 허가하지 않는 것이다. 

```js
function foo() {
	"use strict";	// turn on strict mode
	a = 1;			// `var` missing, ReferenceError
}

foo();
```

코드에 엄격 모드를 적용한다면 에러가 발생하거나 코드가 버그처럼 행동하기 시작하면, 엄격 모드를 피하고 싶은 유혹에 빠진다. 그러나 그 본능은 좋은 생각이 아니다. 엄격 모드가 프로그램에 문제를 발생시킨다면, 프로그램에 반드시 수정해야할 것이 있다는 거의 확실한 신호이다.

엄격 모드는 코드를 안전한 경로를 유지하게 하고 최적화하게 하는 것 뿐만 아니라 언어의 향후 방향을 나타낸다. 엄격 모드를 미루는 것 보다 엄격 모드에 익숙해지는 것이 더 쉽다. 나중에 변환하는 것이 더 어려울 것이다.

참고: 엄격 모드에 대한 더 많은 정보는 이 시리즈의 *Types & Grammar*의 제 5장을 살펴보자.

# Functions As Values

지금까지, 자바스크립트에서 스코프의 기본 구조로서의 함수에 대해 알아봤다. 다음과 같은 일반적인 `function` 선언 구문을 떠올린다.

```js
function foo() {
	// ..
}
```

그 구문으로부터 명확하게 보이지는 않지만, `foo`는 기본적으로 선언된 `function`를 참조하는 외부 스코프에 있는 변수다. 즉, `function` 그 자체가 `42` 또는 `[1,2,3]`과 같은 값이다.

처음엔 이상하게 들리겠지만, 잠시 생각해보자. 값(인수)을 함수에 전달할 뿐만 아니라, 함수 그 자체가 변수에 할당될 수 있고, 다른 함수로 전달되거나, 다른 함수로부터 반환되는 값이 될 수 있다. 

따라서, 함수 값은 마치 다른 값 또는 표현식처럼 표현식으로 생각되어야 한다. 

다음을 생각해보자.

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

변수 `foo`에 할당된 첫 번째 함수 표현식은 `name`(함수명)이 없기 때문에 익명함수라고 한다. 두 번째 함수 표현식은 변수 `x`에 할당된 것을 참조하더라도 `bar`라는 이름이 지정된다. 익명 함수 표현식은 여전히 매우 일반적이지만, 유명 함수 표현식이 더 바람직하다. 

더 많은 정보는 이 시리즈의 *Scope & Closure*를 살펴보자.

# Immediately Invoked Function Expressions (IIFEs)

이전 예제에서, 예를 들어 `foo` 또는 `x`가 포함되었다면 실행할 수 있었지만, 어떤 함수 표현식도 실행되지 않았다. 

함수 표현식을 실행하기 위한 또 다른 방법은 즉시 실행 함수 표현식(IIFE)이다.

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```

`(function IIFE(){..}`함수 표현식을 둘러싼 외부 `(..)`는 정상적인 함수 선언으로 취급되는 것을 방지하기 위해 필요한 자바스크립트 문법의 미묘한 차이이다. 

`})();` 줄의 표현식의 마지막 `()`은 직전을 참조한 함수 표현식을 즉시 실행하는 것이다. 

이상해 보일지 모르지만, 처음만큼 낯선 것은 아니다. `foo`와 `IIFE`의 유사점을 생각해보자.

```js
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

보다시피, `()` 실행하기 전 `(function IIFE(){..}` 나열하는 것은 `();` 실행하기 전 `foo`를 포함하는 것과 본질적으로 같다. 두 경우에서, 함수 참조는 `()` 뒤에 즉시 실행된다.

IIFE는 함수이고 함수는 변수 스코프를 만들기 때문에, 이 방식에서 IIFE는 IIFE 외부를 둘러싼 코드에 영향을 미치지 않는 변수를 선언하는데 종종 사용된다. 

```js
var a = 42;

(function IIFE(){
	var a = 10;
	console.log( a );	// 10
})();

console.log( a );		// 42
```

IIFE는 또한 값을 반환한다.

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

값 `42`는 실행중인 `IIFE`라는 이름의 함수로부터 `return`된 후 `x`에 할당된다. 

# Closure

클로저는 가장 중요하고 이해하기 힘든 자바스크립트 개념 중 하나다. 여기에서는 자세히 다루지 않는 대신 이 시리즈의 *Scope & Closures*를 참조하자. 그러나 일반적인 개념을 이해하기위한 몇 가지를 이야기하고 싶다. 가장 중요한 자바스크립트 기술 중 하나다.

함수가 작동을 끝냈더라도 함수의 스코프(변수)를 "기억하는" 그리고 계속 접근하는 방법으로서 클로저를 생각하라. 

다음을 생각해보자.

```js
function makeAdder(x) {
	// parameter `x` is an inner variable

	// inner function `add()` uses `x`, so
	// it has a "closure" over it
	function add(y) {
		return y + x;
	};

	return add;
}
```

외부 `makeAdder(..)`를 호출하는 것으로 반환되는 내부 `add(..)` 함수를 참조하는 것은 값 `x`가 `makeAdder(..)`에 전달되는 것을 기억할 수 있다. 이제 `makeAdder(..)`를 사용해보자.

```js
// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );		// 4  <-- 1 + 3
plusOne( 41 );		// 42 <-- 1 + 41

plusTen( 13 );		// 23 <-- 10 + 13
```

이 코드가 어떻게 작동하는 지에 대한 추가 정보들:

1. `makeAdder(1)`을 호출할 때, `x`를 `1`로 기억하는 내부 `add(..)`에 참조한다. 이 함수 참조 `plusOne(..)`를 호출한다.
2. `makeAdder(10)`을 호출할 때, `x`를 `10`으로 기억하는 내부 `add(..)`를 참조한다. 이 함수 참조 `plusTen(..)`를 호출한다.
3. `plusOne(3)`을 호출할 때, 3(내부 `y`)을 `1`(`x`에 의해 기억되는)에 더하고 그 결과로 `4`를 얻는다.
4. `plusTen(13)`을 호출할 때, 13(내부 `y`)을 `10`(`x`에 의해 기억되는)에 더하고 그 결과로 `23`을 얻는다.

처음에 이상하게 생각되고 혼란스러워도 걱정하지 않아도 된다. 완전하게 이해하기 위해서 많은 연습이 필요하다. 

그러나 일단 당신이 그렇게하면, 모든 프로그래밍에서 가장 강력하고 유용한 기술 중 하나입니다. 잠시동안 클로저에서 머리를 쓸 가치가 충분하다. 다음 섹션에서 클로저를 조금 더 연습할 것이다.

# Modules

자바스크립트에서 클로저의 가장 일반적인 사용은 모듈 패턴이다. 모듈은 외부로부터 숨겨진 프라이빗(private) 실행 세부사항(변수, 함수)과 외부에서 접근 가능한 퍼블릭(public) API를 정의한다.

다음을 생각해보자.

```js
function User(){
	var username, password;

	function doLogin(user,pw) {
		username = user;
		password = pw;

		// do the rest of the login work
	}

	var publicAPI = {
		login: doLogin
	};

	return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( "fred", "12Battery34!" );
```

`user()` 함수는 `doLogin()` 함수 뿐만아니라 변수 `username`과 `password`를 가지고 있는 외부 스코프 역할을 한다. 모두 외부로부터 접근할 수 없는 `user` 모듈의 프라이빗 내부 세부사항이다.

경고 : 대부분의 독자에겐 일반적인 것처럼 보일지 모르지만, 여기에선 `new User()`을 호출하지 않는다. `User()`는 인스턴스화될 클래스가 아닌 함수이므로, 정상적으로 호출된다. `new`를 사용하는 것은 부적절하고 자원낭비이다.
 
`User()`를 실행은 `user` 모듈의 인스턴스를 생성한다. 각각의 내부 변수와 함수의 완전히 새로운 복사본인 완전히 새로운 스코프가 생성된다. 이 인스턴스를 `fred`에 할당한다. `User()`를 다시 실행하면, `fred`로부터 완전히 분리된 새로운 인스턴스를 얻게된다. 

`doLogin()`함수는 `User()`함수가 실행을 마친 후에도 접근할 수 있는 `username`과 `password`에 대한 클로저를 가지고 있다.

`publicAPI`는 한 개의 속성과 메소드를 가진 내부 `doLogin()`함수를 참조하는 `login`을 가진 객체이다. `publicAPI`를 반환할 때, `fred`를 호출하는 인스턴스가 된다.
 
이 시점에서, 외부 `User()`함수는 실행이 종료되었다. 일반적으로, `username`과 `password` 같은 내부 변수는 사라졌다고 생각할 것이다. 그러나 그렇지않다. 그 변수들이 살아있도록 유지하는 `login()` 함수에 클로저가 있기 때문이다.

그래서 내부 `doLogin()`을 호출하는 것과 같이 `username`과 `password`에 접근할 수 있는 `fred.login(..)`을 호출할 수 있다.

약간 혼란스러운 점이 있긴하지만 클로저와 모듈 패턴을 간략하게 살펴보기에 좋은 기회였다. 괜찮다. 이해하기 위해서 더 많은 작업이 필요하다.여기에서 더 깊이있는 탐험을 위해 이 시리즈의 *Scope & Closure*를 읽어보자.

# `this` Identifier

자바스크립트에서 일반적으로 오해하고 있는 또다른 개념이 `this` 식별자이다. 이 시리즈의 *this & Object Prototypes* 에 this에 대한 몇가지 장이 있기 때문에 개념만 간단히 소개하겠다.

`this`는 "객체지향패턴"과 관련이 있는 것처럼 보이지만 자바스크립트에서 `this`는 다른 매커니즘이다.  

함수가 `this` 참조를 가지고 있다면 `this` 참조는 `객체 object`를 가리킨다. 그러나 그것이 가리키는 `객체 object`는 어떻게 함수가 호출되는지에 달려있다.

가장 일반적인 오해와 마찬가지로, `this`가 함수 그 자체를 참조하고 있지 않다는 것을 깨닫는 것이 중요하다.

간단한 예를 살펴보자.

```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

// --------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );	// "obj2"
new foo();			// undefined
```

어떻게 `this` 설정을 위한 4개의 규칙이 있다. 예제의 마지막 네 줄에 표시된다.

1. `foo()`함수는 , 엄격모드에서 `this`는 `undefined`되고 `bar` 속성에 접근할 때 에러가 발생하기 때문에 `this` 비엄격모드에서 전역 객체로 `this` 설정을 끝낸다. `"global"`은 `this.bar`에서 나온 값이다.
2. `obj1.foo()` `obj1`객체에 `this`를 설정한다.
3. `foo.call(obj2)`는 `obj2`객체에 `this`를 설정한다.
4. `new foo()`는 새로운 빈 객체에 `this`를 설정한다.

결론 : `this`가 가리키는 것을 이해하기 위해서, 문제에서 어떻게 함수가 호출되는지를 검토해야한다. 4가지 방법 중 하나로 `this`가 무엇인지에 대한 답이 나올 것이다.
 
참고 : `this`에 대한 더 많은 정보는 *this & Object Prototypes*의 1장과 2장을 살펴보자.

# Prototypes

자바스크립트에서 프로토타입 매커니즘은 매우 복잡하다. 여기에서는 훑어 볼 것이다. 모든 세부사항은 이 시리즈의 *this & Object Prototypes* 4장과 6장에서 더 많은 시간을 할애할 것이다.

객체 속성을 참조할 때, 속성이 없으면 자바스크립트는 자동적으로 속성을 찾을 또다른 객체를 찾는데 객체의 내부 프로토타입 참조를 사용한다. 속성이 사라졌을 때, 대비책으로 생각할 수 있다.
  
내부 프로토타입은 하나의 객체로부터 객체가 생성되는 그 순간에 발생하는 대체제까지 연결을 참조한다. 이것을 설명하기 위해 가장 간단한 방법은 내장 유틸리티를 사용하여 `Object.create(..)`를 호출하는 것이다.

다음을 생각해보자.

```js
var foo = {
	a: 42
};

// create `bar` and link it to `foo`
var bar = Object.create( foo );

bar.b = "hello world";

bar.b;		// "hello world"
bar.a;		// 42 <-- delegated to `foo`
```

`foo`와 `bar` 객체들 그리고 그들의 관계를 시각화하는데 도움을 될 것이다.

<img src="fig6.png">

`a` 속성은 `bar` 객체에 사실 존재하지 않지만, `bar`는 `foo`에 프로토타입 연결이기 때문에, 자바스크립트는 `a`가 발견되었던 `foo` 객체에서 `a` 찾기위해 자동적으로 되돌아간다. 

이 연결은 언어의 이상한 특징처럼 보일지 모른다. 이 특징이 사용되는 가장 일반적인 방법 -- 본인도 많이 사용하는 -- 은 "상속"으로 "클래스" 메커니즘을 모방/위조하려는 것이다.

그러나 프로토타입을 적용하는 보다 자연스러운 방법은 필요 행동의 부분을 위해 하나로부터 다른 것으로 위임할 수 있는 연결된 객체 의도적으로 설계하는 "행동 위임"이라는 패턴이다.
 
참고 : 프로토타입과 행동 위임에 대한 더 많은 정보를 위해 이 시리즈의 *this & Object Prototypes*의 4장부터 6장까지 살펴보자. 



























